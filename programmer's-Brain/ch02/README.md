# CHAPTER 2 신속한 코드 분석

> 경험 많은 개발자조차 코드를 빨리 이해하는 것이 어려운 이유
>
> 두뇌가 정보들을 어떻게 인식 가능한 부분으로 나누는지에 대한 이해
>
> 단어와 코드 같은 정볼르 분석할 때 LTM과 STM 사이의 상호작용
>
> 코드 분석 시 영상 기억 공간의 역할
>
> 코드 기억을 통한 코드 수준의 자가 진단
>
> 읽기 쉬운 코드를 작성하는 법



## 2.1 코드를 신속하게 읽기

<br>

> "프로그램은 사람이 읽을 수 있도록 작성해야만 한다. 기계가 실행하는 것은 부차적인 일이다."
>
> <컴퓨터 프로그램의 구조와 해석> - 해럴드 아벨슨, 제럴드 제이 서스먼, 줄리 서스먼 -

<br>

대부분 프로그래머들은 코드를 읽는 법보다 작성하는 법을 훨씬 더 많이 연습을 합니다. 이러한 현상은 대부분 코드를 만들어내는 것에 관심을 많이 갖습니다. 대학, 직장 혹은 부트캠프에서도 일단 프로그래밍을 배우고 나면 코드를 작성하는 것에 훨씬 더 많은 관심과 시간을 갖게 됩니다. 구체적으로, 문제를 어떻게 풀고 그것을 코드로 어떻게 구현하는지를 집중적으로 훈련을 해요. 반대로, 코드를 읽는 연습은 거의 전무합니다. 

<br>

코드를 읽는 목적은 다양합니다. 예를 들어서, 기능을 추가하거나 버그를 발견하기 위해서 혹은 코드가 실행될 더 큰 시스템을 이해하기 위해서입니다. 이 모든 상황에서 한 가지 공통점은 코드를 읽을 때 우리는 그 코드에 존재하는 특정한 정보를 찾는다는 점입니다.

-  코드를 읽는다 ➡️ **코드에 존재하는 우리가 원하는 특정한 정보를 찾는다**

-  코드 읽기 능력의 향상 ➡️ **학습 능력 향상 또는 버그 수정이나 새로운 기능 추가 등 시간을 허비하지 않는다**

<br>

### 2.2.1 두뇌에서 무슨 일이 일어나는가?

<br>

STM이 하는 역할을 좀 더 깊이 있게 학습하기 위해서 삽입 정렬(Insertion sort)알고리즘을 구현한 자바 코드를 살펴봅니다. 시계 또는 스탑워치를 이용해서 3분 이상은 쓰지 않고 읽어보기 바랍니다. 3분이 지나면 코드를 종이나 손으로 가려야 합니다.

<br>

**코드를 가린 채, 삽입 정렬을 그대로 재현해 보는 겁니다.**

~~~java
public class InsertionSort {
	public static main(String[] ars) {
        int[] array = {45, 12, 85, 32, 89, 39, 69, 44, 42, 1, 6, 8};
        int temp;
        for ( int i = 1; i < array.length; i++ ) {
            for ( int j = i; j > 0; j -- ) {
                if ( array[j] < array[j - 1] ) {
                    temp = array[j];
                    array[j] = array[j - 1];
                    array[j - 1] = temp;
                }
            } 
        }
        for ( int i = 0; i < array.length; i++) {
            System.out.println(array[i]);
        }
    }
}
~~~

<br>

**1. STM**

코드를 읽는 과정에서 변수, 자료형, 배열 등 코드 정보들이 STM에 저장됩니다.



**2. LTM**

LTM은 두 가지 방법으로 STM에 저장된 정보를 더 추가합니다.

1. **프로그래밍 언어 문법에 대한 지식**
   -  for, if문에 대한 지식 등

1. **이 코드가 어떤 기능을 하는 코드라는 지식**
   -  STM에 모든 코드를 저장하지 못하더라도, 코드에서 이 동작이 수행되어야 한다는 짐작이 가능 

➡️ 이 둘이 함께 사용되어 코드를 재현해낼 수 있음



<br>



### 2.1.4 생소한 코드를 읽는 것은 왜 어려운가?

두번째 코드가 훨씬 어려운 이유(삽입 정렬의 pseudo code 입니다. )

![2-1](https://devjin-blog.com/static/7ce000c787ff62b7bbd15eb9ae0bce1f/3c5de/insertion_sort_pseudo.png)

1. 코드가 무슨 일을 하는지 알지 못함 ➡️ **LTM에서 참조하여 추측할 수 없어진다.**
2. **"이상한 변수명"** 을 사용하여 기억하는 것을 어렵게 만든다.

➡️ 우리의 **STM의 용량에 제한**이 있기 때문에 기억이 어려움 😭

<br>

코드에 있는 정보를 모두 다 STM에 저장하고 처리하는 것은 물리적으로 불가능합니다.(물리적 = 🧠) 아시다시피, STM은 읽거나 들은 정보를 짧은 시간만 저장합니다. 여기서 짧은 시간이라는 것은 정말로 짧은 시간을 의미하는데 연구에 의하면 30초를 넘기지 않습니다. 30초 후에 그 정보는 LTM에 저장 또는 잊혀지게 됩니다. 그리고 STM은 시간 뿐만 아니라, 크기도 제한 받습니다. 

컴퓨터와 비슷하게, 우리 두뇌에서 LTM은 STM보다 기억 용량이 훨씬 더 큽니다. 하지만 컴퓨터의 메인메모리와 다르게, STM의 용량은 불과 몇 개 정도밖에 되지 않습니다.

> < The Magical Number Seven Plus or Minus Two: Some Limits on Our Capacity for Processing Information >
>
> -조지 아마티지 밀러(George Armitage Miller) 논문-

저명한 20세기 인지과학자 밀러가 1956년에 발표한 유명한 논문에서 잘 설명을 하고 있습니다. 

<br>

좀 더 최근의 연구에서는 STM의 용량이 2개에서 6개 사이로 심지어 더 적다고 추정한 논문이 등장하고 있습니다. 이 용량은 전 세계 거의 모든 사람에게 해당하고, 과학자들은 STM의 용량을 향상하는 방법을 아직 찾지 못했다고 합니다.

> 기억 공간이 채 1바이트도 되지 않는 인간이 그 많은 일을 수행하는 게 기적이 아닐까요?



## 2.2 기억의 크기 제한을 극복하기

<br>

최대 6개 정보만 저장한다는 것은, 그 이후의 정보를 기억하려는 순간 앞에 읽은 정보를 잊어버려야 합니다. 하지만 당연하게도 우리는 6개 이상의 변수 또는 자료형을 기억할 수 있습니다. 이게 어떻게 가능한 것인지 알아보도록 합니다.

<br>

### 2.2.1 단위로 묶는 것의 위력

<br>

**Chunk**
각각을 기억하는 것이 아닌, 어떠한 그룹으로 묶어 기억하는 것이다.
⚡이렇게 그룹으로 묶을 때엔 LTM에 있는 지식이 필요합니다. 어떠한 지식도 없으면 단위/패턴으로 묶을 수도 없습니다.

**코드에서의 Chunking**
LTM에 지식이 많을수록 Chunking이 쉽고 기억을 쉽게 만든다.
→ 전문가는 초보보다 더 코드를 잘 기억한다 (당연히도...)

💡 하지만 무작위 코드의 경우 전문가와 초보의 차이가 없습니다.LTM을 활용할 수 없기 때문이에요.

<br>

## 2.3 읽는 것보다 보는 것이 더 많다

<br>

정보 → 감각(오감) → **감각 기억 공간(sensory memory)** → STM
코드 → 감각 👀 → **영상 기억 공간(iconic memory)** → STM

우리가 STM에 기억하는 것보다 더 많은 정보가 순간적으로 영상 기억 공간에 저장되었다가 휘발됩니다.

<br>

### 2.3.2 기억하는 대상이 중요한 것이 아니고 기억하는 방식이 중요하다

<br>

**"무엇"** 을 기억해냈느냐뿐만 아니라 코드를 어떤 **"순서"** 로 기억했는지를 파악하는 것은 중요한 요소입니다.

>코드를 **어떤 순서**로 기억했는지도 중요한 요소 → 정보의 **연관성**
>전문가 집단이 초보자 집단보다 더 이미 있는 지식을 가지고 순서를 정함

<br>

### 더 읽기 좋은 코드를 작성하는 방법

<br>

### **디자인 패턴의 사용** 

- 디자인 패턴에 대한 지식 향상 ⬆️
  1. 코드 청킹 능력 향상
  1. 더 빠른 코드 읽기 / 수정 가능

➕ 디자인 패턴에 따른 차이도 있습니다.

<br>

### 주석문 쓰기

주석문이 포함되어 있을 때, 코드 가독성이 크게 증가합니다. 즉, 주석문을 유의미하게 읽는다는 증거입니다.

1. 주석문이 있으면 새로운 팀원이 코드를 더 쉽게 읽을 수 있다.
2. 개발자가 코드를 청킹할 때 주석문의 도움을 받을 수 있다. (고수준 주석문의 경우에만!)

<br>

### 표식 `(beacon)` 남기기

코드를 읽다가 **'아 이거구나'** 라고 생각하게 되는 부분을 의미합니다.
주석문, 변수명, 필드명, 도출되는 문자열의 값 등이 표식이 될 수 있습니다.

1️⃣ 단순 표식
코드의 문법을 통해 의미가 자명한 표식 ➡️ 변수명, 연산자, if 구조문, &&, +, >, 등...

2️⃣ 복합 표식
단순 표식들이 모여 실행되는 기능에 대해서 알려주는 표식

<br>

### 2.3.3 청킹 연습

청킹을 **의도적으로 연습** 하는 방법 ➡️ 적극적으로 코드를 기억해내는 훈련을 의미합니다.

- **1단계 : 코드 선정** 

  어느정도 익숙해져 있는 코드베이스를 하나 고릅니다. (언어에 대한 지식이 어느 정도 있어야 함, 50줄 ⬇️)

- **2단계: 코드 파악**

  최대 2분을 넘지 않도록 코드를 파악합니다.

- **3단계: 코드 재현**

  종이 또는 IDE에서 새로 파일을 생성하고 코드를 다시 작성합니다.

- **4단계: 회고**

  모든 코드를 최대한 작성한 후, 원래 코드와 비교해보고 다음의 질문에 답해봅니다.

  1. 어느 부분을 쉽게 기억했는가?
  2. 부분적으로 기억한 코드가 있는가?
  3. 전체를 다 기억하지 못한 코드가 있는가?
  4. 기억하지 못한 라인들이 있다면 그 이유가 무엇일까?
     - 기억하지 못한 라인에 익숙하지 않은 개념이 들어 있지는 않은가?
     - 기억하지 못한 라인에 익숙하지 않은 도메인 지식이 있지는 않은가?

- **5단계: 다른 사람과 비교 ( 생략 가능 )**

  청킹 능력을 키우기 원하는 주변 동료가 있다면 이 연습을 같이해도 좋습니다. 재현한 코드를 비교해보는 것은 매우 흥미로운 일이 됩니다. 초급 개발자와 숙련 개발자 사이에는 큰 차이가 있기 때문에 다른 사람과 비교해서 자신의 프로그래밍 수준이 어느 정도인지 가늠해보는 데에도 유용합니다.

