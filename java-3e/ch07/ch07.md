# 다형성(polymorphism)

---

## 5.1 다형성이란?

> 객체지향이론에서 다형성은 여러 가지 형태를 가질 수 있는 능력을 의미
>
> 자바에서는 한 타입의 참조변수로 여러 타입 객체를 참조



<br>



구체적으로, 자바에서는 **조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 한 것을 의미**합니다. 

~~~java
class Tv {
    boolean power;
    int channel;
    
    void power() { power = !power; }
    void channelUp() { ++channel; }
    void channelDown() { --channel; }
}

class CaptionTv extends Tv {
    String text;
    void caption() { /* 내용생략 */ }
}
~~~

Tv클래스와 CaptionTv 클래스가 위처럼 정의되어 있을 때, 서로 상속관계에 있으며 두 클래스의 인스턴스를 생성하고 사용하기 위해서는 다음과 같이 할 수 있습니다.

~~~java
Tv t = new Tv();
Caption c = new CaptionTv();
~~~

보통 일반적으로 인스턴스의 타입과 참조변수의 타입이 일치하는 것이 일반적이에요. 근데, **Tv클래스와 CaptionTv클래스처럼 서로 상속관계에 있을 경우에는 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조하도록 하는 것이 가능합니다!**

```java
Tv t = new CaptionTv();	// 조상 타입의 참조변수로 자손 인스턴스를 참조
```



<br>

음,, 지금까지 클래스를 참조한 방식과는 달라서 많이 생소합니다. 인스턴스를 같은 타입의 참조변수로 참조하는 것과 조상타입의 참조변수로 참조하는 것은 어떤 차이가 있는지 알아보면서, 이 생소한 것을 할 필요가 있을지에 대해서 알아봅시다.

```java
CaptionTv c = new CaptionTv();
Tv t = new CaptionTv();
```

위의 코드에서 CaptionTv 인스턴스를 2개 생성하고, 각 참조변수 `c, v`에 인스턴스를 하나씩 참조하도록 했습니다. 이 경우, 실제 인스턴스가 CaptionTv타입이라 할지라도, 참조변수 t로는 CaptionTv인스턴스의 모든 멤버를 사용할 수 없습니다! 참고로, 참조변수 t가 조상클래스를 참조하는 녀석이에요. 벌써 느낌이 오셨을까요!?

<br>

왜냐하면, Tv타입의 참조변수로는 자손클래스의 CaptionTv인스턴스 중에서 Tv 클래스의 멤버들(상속받은 멤버 포함)만 사용할 수 있습니다. 따라서, 생성된 CaptionTv인스턴스의 멤버 중에서 Tv클래스에 정의 되지 않은 멤버, text, caption()은 참조변수 t로 사용이 불가능합니다. `t.text, t.caption()` 처럼 사용이 불가능합니다. **둘 다 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 전혀 다르기 때문입니다.**

<br>

그렇다면, 이번에는 자손클래스가 참조변수, 조상클래스가 인스턴스가 되어서 참조하는 것은 가능할까요?

```java
CaptionTv c = new Tv(); // 불가능합니다!
```

완전 불가능입니다. 위의 코드를 실행할 경우, 컴파일에서 에러가 발생합니다. 그 이유는 **실제 인스턴스인 Tv의 멤버 개수보다 참조변수 c가 사용할 수 있는 멤버 개수가 더 많기 때문입니다.** 쉽게 말하자면, CaptionTv 클래스에는 text와 caption()이 정의 되어 있습니다. 그래서 참조변수 c를 통해서, `c.text, c.caption()`과 같은 방식으로 c가 참조하고 있는 인스턴스에서 text와 caption()을 사용하려 할 수 있는 것입니다. 하지만, c가 참조하고 있는 인스턴스는 Tv클래스입니다. Tv클래스의 인스턴스에는 text와 caption()이 존재하지 않기 때문에 이들을 사용하려 하면 문제가 발생하는 것입니다.

<br>

그래서, **자손클래스의 참조변수로 조상클래스의 인스턴스를 참조하는 것은 존재하지 않은 멤버를 사용할 가능성이 있기 때문에 허용되지 않습니다.** 그렇다고 무조건 안되는 것은 아닙니다. **참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적으면 가능합니다.**

<br>

>  클래스는 상속을 통해서 확장될 수는 있어도 축소될 수는 없어서, 
>
>  조상 인스턴스의 멤버 개수는 자손 인스턴스의 멤버 개수보다 항상 적거나 같다.

> 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
>
> 반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수 는 없다.

**참조변수의 타입이 참조변수가 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 개수를 결정한다는 것은 매우 중요**합니다. 그렇다면, 인스턴스의 타입과 일치하는 참조변수를 사용하면 인스턴스의 멤버들을 모두 사용할 수 있을텐데 왜 조상타입의 참조변수를 사용해서 인스턴스의 일부 멤버만을 사용하는 것일까요? 천천히 알아보도록 하죠!

<br>

## 5.2 참조변수의 형변환

> 서로 상속관계에 있는 클래스사이에서만 형변환이 가능하다.
>
> 바로 위의 조상이나 자손이 아닌, 조상의 조상으로도 형변환은 가능하다.
>
> 따라서 모든 참조변수는 모든 클래스의 조상인 Object클래스 타입으로 형변환이 가능하다.

>자손타입 → 조상타입(Up-casting) : 형변환 생략가능
>
>자손타입 ← 조상타입(Down-casting) : 형변환 생략불가능

```java
class Car {
    String color;
    int door;
    
    void drive() {
        System.out.println("drive, Brrrrr~");
    }
    
    void stop() {
        System.out.println("stop!!!!!!!!");
    }  
}


class FireEngine extends Car() {
    void water() {
    	System.out.println("water!!!!!!!");
    }
}

class Ambulance extends Car() {
    void siren() {
    	System.out.println("siren~~~~~~~");
    }
}
```

세 클래스가 정의되어 있을 때, 각 상속 관계에 있는 클래스들은 형변환이 가능합니다. 하지만, 동일한 조상타입을 가진다고 해서 자식타입 간의 형변환은 불가능합니다.

~~~

~~~

